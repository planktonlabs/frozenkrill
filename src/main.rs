use commands::{
    common::{
        calculate_non_duress_output, multisig::open_multisig_wallet_non_interactive,
        singlesig::open_singlesig_wallet_non_interactive,
    },
    generate::DuressPublicInfoParams,
};
use path_absolutize::*;
use std::{
    borrow::Cow,
    path::{Path, PathBuf},
    str::FromStr,
    sync::{Arc, Mutex},
    thread::JoinHandle,
    time::Instant,
};

use frozenkrill_core::{
    anyhow::{self, bail, Context},
    bip39::{self, Language, Mnemonic},
    bitcoin::{
        secp256k1::{All, Secp256k1},
        Network,
    },
    custom_logger,
    key_derivation::{self, default_derive_key, KeyDerivationDifficulty},
    log, mnemonic_utils, rand,
    rand_core::CryptoRngCore,
    random_generation_utils::get_secp,
    wallet_description::{EncryptedWalletVersion, MultisigType, ScriptType, KEY_SIZE, SALT_SIZE},
    DEFAULT_MAX_ADDITIONAL_PADDING, DEFAULT_MIN_ADDITIONAL_PADDING,
};

use clap::{Parser, Subcommand};

use dialoguer::{
    console::Term,
    theme::{ColorfulTheme, SimpleTheme, Theme},
};
use frozenkrill_core::secrecy::{ExposeSecret, Secret, SecretString};
use indicatif::ProgressBar;

use frozenkrill_core::wallet_description::{
    SingleSigWalletDescriptionV0, SinglesigJsonWalletDescriptionV0, WordCount,
};

use crate::progress_bar::get_spinner;

mod commands;
mod progress_bar;

const VERSION: &str = "0.0.0";

const PASSWORD_ENV: &str = "PASSWORD";

const PASSWORD_HELP: &str =
    "Password used to encrypt the file. If not given, a prompt will ask for one";

const KEYFILE_HELP: &str =
    "Files to be used for a complementary 'password'. Can be given multiple times. Multiple files and directories are allowed. Directories are followed recursively";
const ENABLE_DURESS_WALLET: &str =
    "Will enable plausible deniability making the default wallet password a duress one (i.e to be used under coercion)";
const INPUT_WALLET_HELP: &str =
    "The encrypted wallet previously generated by the 'generate' command";
const USE_12_WORDS_HELP: &str = "Use 12 words for the seed phrase instead of the default 24";
const USE_TESTNET_HELP: &str = "Derive addresses and keys for testnet instead of mainnet";
const ADDRESSES_QUANTITY_HELP: &str = "How many addresses to export on public info json";
const DIFFICULTY_HELP: &str = {
    const EASY: KeyDerivationDifficulty = KeyDerivationDifficulty::Easy;
    const EASY_TIME: &str = EASY.estimate_time();
    const EASY_MEMORY: &str = EASY.estimate_memory();
    const NORMAL: KeyDerivationDifficulty = KeyDerivationDifficulty::Normal;
    const NORMAL_TIME: &str = NORMAL.estimate_time();
    const NORMAL_MEMORY: &str = NORMAL.estimate_memory();
    const HARD: KeyDerivationDifficulty = KeyDerivationDifficulty::Hard;
    const HARD_TIME: &str = HARD.estimate_time();
    const HARD_MEMORY: &str = HARD.estimate_memory();
    const VERYHARD: KeyDerivationDifficulty = KeyDerivationDifficulty::VeryHard;
    const VERYHARD_TIME: &str = VERYHARD.estimate_time();
    const VERYHARD_MEMORY: &str = VERYHARD.estimate_memory();
    const_format::formatcp!("How hard is to derive the key.
More specifically, how much cpu (time) and ram memory (space) argon2id will require. Time depends on the platform, but roughly we have:
--difficulty easy: {EASY_TIME}, {EASY_MEMORY}
--difficulty normal: {NORMAL_TIME}, {NORMAL_MEMORY} (the default)
--difficulty hard: {HARD_TIME}, {HARD_MEMORY}
--difficulty veryhard: {VERYHARD_TIME}, {VERYHARD_MEMORY}
To open a encrypted wallet you need to specify the same difficulty used to generate it. If in doubt, leave the default
")
};

const USER_GENERATED_SEED_HELP: &str =
    "Instead of randomly generating the seed, will ask the user to manually input the words";

const ALWAYS_HIDE_TYPED_SEED_HELP: &str = "When --user-generated-seed is used and the user chose to type 12/24 words, the previous typed words will be hidden.
Note: if the user is typing 11/23 words this is already the behavior";

const WALLET_OUTPUT_FILE_HELP: &str = "Where to save the generated encrypted wallet. Any file name is valid as long the file doesn't exists";

const PUBLIC_INFO_JSON_OUTPUT_HELP: &str = "Name of the file to export public parameters and addresses of the wallet into. Useful to import on hot wallets";

const WALLET_FILE_TYPE_HELP: &str = r#"Pick between a 'standard' or a 'compact' wallet.
The standard one will include all metadata required to describe the wallet, while the compact one will only save the encrypted entropy and will rely on implicit standard and conventions.
Use the compact only if you need to save bytes (for instance, to put the wallet in a QR code)"#;

#[derive(clap::Args)]
#[command(
    arg_required_else_help = true,
    about = "Generate a singlesig encrypted wallet"
)]
struct SinglesigGenerateArgs {
    #[clap(flatten)]
    common: GenerateCommon,
    #[clap(
        long,
        action,
        help = USE_12_WORDS_HELP
    )]
    use_12_words: bool,
    #[clap(
        long,
        action,
        help = ENABLE_DURESS_WALLET
    )]
    enable_duress_wallet: bool,
    #[clap(
        long,
        action,
        help = USER_GENERATED_SEED_HELP
    )]
    user_generated_seed: bool,
    #[clap(
        long,
        action,
        help = ALWAYS_HIDE_TYPED_SEED_HELP
    )]
    always_hide_typed_seed: bool,
    #[clap(
        help = WALLET_OUTPUT_FILE_HELP
    )]
    wallet_output_file: Option<String>,
    #[clap(
        help = PUBLIC_INFO_JSON_OUTPUT_HELP
    )]
    public_info_json_output: Option<String>,
}

#[derive(clap::Args)]
struct GenerateCommon {
    #[clap(
        long,
        action,
        help = "Disable all padding, the file will be as small as possible but now an attacker may infer something about its contents using the file size. Be careful, only use this if you know what you're doing"
    )]
    disable_all_padding: bool,
    #[clap(
        long,
        default_value_t = DEFAULT_MIN_ADDITIONAL_PADDING
    )]
    min_additional_padding_bytes: u32,
    #[clap(
        long,
        default_value_t = DEFAULT_MAX_ADDITIONAL_PADDING
    )]
    max_additional_padding_bytes: u32,
    #[clap(
        long,
        action,
        help = USE_TESTNET_HELP
    )]
    use_testnet: bool,
    #[clap(
        long,
        help = KEYFILE_HELP
    )]
    keyfile: Vec<String>,
    #[clap(
        long,
        help = DIFFICULTY_HELP,
        default_value_t = key_derivation::DEFAULT_DIFFICULTY_LEVEL
    )]
    difficulty: KeyDerivationDifficulty,
    #[clap(long, help = ADDRESSES_QUANTITY_HELP, default_value = "100")]
    addresses_quantity: u32,
    #[clap(long, help = WALLET_FILE_TYPE_HELP,
        default_value_t = WalletFileType::Standard)]
    wallet_file_type: WalletFileType,

    #[clap(
        long,
        env = PASSWORD_ENV,
        help = PASSWORD_HELP
    )]
    password: Option<String>,
}

#[derive(Clone, Copy)]
pub enum WalletFileType {
    Standard,
    Compact,
}
impl WalletFileType {
    pub fn to_encrypted_wallet_version(
        self,
        network: Network,
        script_type: ScriptType,
    ) -> anyhow::Result<EncryptedWalletVersion> {
        match self {
            Self::Standard => Ok(EncryptedWalletVersion::V0Standard),
            Self::Compact => match (network, script_type) {
                (Network::Bitcoin, ScriptType::SegwitNative) => {
                    Ok(EncryptedWalletVersion::V0CompactMainnet)
                }
                (Network::Testnet, ScriptType::SegwitNative) => {
                    Ok(EncryptedWalletVersion::V0CompactTestnet)
                }
                (other, ScriptType::SegwitNative) => {
                    bail!("Unsupported bitcoin network: {other:?}")
                }
            },
        }
    }
}
impl FromStr for WalletFileType {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.trim().to_lowercase().as_str() {
            "standard" => Ok(Self::Standard),
            "compact" => Ok(Self::Compact),
            other => bail!("Got '{other}', it should be either 'standard' or 'compact'"),
        }
    }
}

impl std::fmt::Display for WalletFileType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            WalletFileType::Standard => f.write_str("standard"),
            WalletFileType::Compact => f.write_str("compact"),
        }
    }
}

#[derive(clap::Args)]
#[command(
    arg_required_else_help = true,
    about = "Generate a multisig encrypted wallet"
)]
struct MultisigGenerateArgs {
    #[clap(flatten)]
    common: GenerateCommon,
    #[clap(help = "Multisig configuration to be used, like 2-of-3, 3-of-5, etc")]
    configuration: MultisigType,
    #[clap(
        long,
        help = WALLET_OUTPUT_FILE_HELP
    )]
    encrypted_wallet_output_file: Option<String>,
    #[clap(
        long,
        help = PUBLIC_INFO_JSON_OUTPUT_HELP
    )]
    json_output_file: Option<String>,
    #[clap(
        help = "Input wallets to use as signers/public keys. May be a encrypted wallet or just the json with public information (xpub, derivation path, etc)"
    )]
    input_files: Vec<String>,
}

#[derive(clap::Args)]
#[command(
    about = "Shows the seed and private key. It should only be used if you are going to move the funds to another wallet"
)]
struct SinglesigShowSecretsArgs {
    #[clap(
        long,
        action,
        help = "This flag is mandatory because the 'show-secrets' command will expose secrets and therefore should carefully be used in extraordinary circumstances"
    )]
    acknowledge_dangerous_operation: bool,
}

#[derive(clap::Args)]
#[command(about = "Show wallet contents")]
struct MultisigShowSecretsArgs {}

#[derive(clap::Args)]
struct CommonExportPublicInfoArgs {
    #[clap(long, help = ADDRESSES_QUANTITY_HELP, default_value = "100")]
    quantity: u32,
    #[clap(long, help = "Index of first address", default_value = "0")]
    first_index: u32,
    #[clap(help = "Destination JSON file")]
    output_file_json: Option<String>,
}

#[derive(clap::Args)]
#[command(
    about = "Export public parameters and addresses of the wallet. Useful to import on hot wallets"
)]
struct SinglesigExportPublicInfoArgs {
    #[clap(flatten)]
    common: CommonExportPublicInfoArgs,
    #[clap(help = "Destination non duress JSON file")]
    non_duress_output_file_json: Option<String>,
}

#[derive(clap::Args)]
#[command(about = "Export wallet info in json format")]
struct MultisigExportPublicInfoArgs {
    #[clap(flatten)]
    common: CommonExportPublicInfoArgs,
}

#[derive(clap::Args)]
#[command(about = "Show a receiving address QR Code by index")]
struct ShowReceivingQrCodeArgs {
    #[clap(
        help = "Which address to show. Zero is first address",
        default_value = "0"
    )]
    address_index: u32,
    #[clap(
        short,
        long,
        help = "Amount to receive in btc/satoshis, like '2.3 btc' or '1500 sats'"
    )]
    amount: Option<String>,
}

#[derive(clap::Args)]
#[command(about = "Sign a PSBT file")]
struct SignPsbtArgs {
    #[clap(help = "Input PSBT file (commonly with a .psbt extension)")]
    input_psbt_file: String,
    #[clap(help = "The output PSBT file with this wallet signature")]
    signed_output_psbt_file: Option<String>,
}

#[derive(clap::Args)]
#[command(about = "Reencode the wallet with new password and other parameters")]
struct SinglesigReencodeArgs {
    #[clap(flatten)]
    common: GenerateCommon,
    #[clap(
        help = WALLET_OUTPUT_FILE_HELP
    )]
    wallet_output_file: Option<String>,
}

#[derive(Subcommand)]
enum SinglesigOpenCommands {
    ShowSecrets(SinglesigShowSecretsArgs),
    ShowReceivingQrCode(ShowReceivingQrCodeArgs),
    ExportPublicInfo(SinglesigExportPublicInfoArgs),
    SignPsbt(SignPsbtArgs),
    Reencode(SinglesigReencodeArgs),
}

#[derive(clap::Args)]
#[command(about = "Reencode the wallet with new password and other parameters")]
struct MultisigReencodeArgs {
    #[clap(flatten)]
    common: GenerateCommon,
    #[clap(
        help = WALLET_OUTPUT_FILE_HELP
    )]
    wallet_output_file: Option<String>,
}

#[derive(Subcommand)]
enum MultisigOpenCommands {
    ShowSecrets(MultisigShowSecretsArgs),
    ShowReceivingQrCode(ShowReceivingQrCodeArgs),
    ExportPublicInfo(MultisigExportPublicInfoArgs),
    SignPsbt(SignPsbtArgs),
    Reencode(MultisigReencodeArgs),
}

#[derive(clap::Args)]
struct CommonOpenArgs {
    #[clap(
        long,
        help = KEYFILE_HELP
    )]
    keyfile: Vec<String>,
    #[clap(
        long,
        help = DIFFICULTY_HELP,
        default_value_t = key_derivation::DEFAULT_DIFFICULTY_LEVEL
    )]
    difficulty: KeyDerivationDifficulty,
    #[clap(
        help = INPUT_WALLET_HELP
    )]
    wallet_input_file: String,

    #[clap(
        long,
        env = PASSWORD_ENV,
        help = PASSWORD_HELP
    )]
    password: Option<String>,
}

#[derive(clap::Args)]
#[command(
    arg_required_else_help = true,
    about = "Open a singlesig wallet to make an operation"
)]
struct SinglesigOpenArgs {
    #[clap(flatten)]
    common: CommonOpenArgs,
    #[clap(
        long,
        action,
        help = ENABLE_DURESS_WALLET
    )]
    enable_duress_wallet: bool,
    #[clap(subcommand)]
    command: SinglesigOpenCommands,
}

#[derive(clap::Args)]
#[command(
    arg_required_else_help = true,
    about = "Open a multisig wallet to make an operation"
)]
struct MultisigOpenArgs {
    #[clap(flatten)]
    common: CommonOpenArgs,
    #[clap(short, long, help = "Input wallets to use as signers")]
    input_files: Vec<String>,
    #[clap(subcommand)]
    command: MultisigOpenCommands,
}

#[derive(clap::Args)]
#[command(about = "Generate many encrypted wallets")]
struct SinglesigBatchGenerateExportArgs {
    #[clap(flatten)]
    common: GenerateCommon,
    #[clap(
        long,
        action,
        help = USE_12_WORDS_HELP
    )]
    use_12_words: bool,
    #[clap(
        long,
        action,
        help = ENABLE_DURESS_WALLET
    )]
    enable_duress_wallet: bool,
    #[clap(
        long,
        action,
        help = "Will NOT export the json with the xpub, receiving addresses and other params"
    )]
    disable_public_info_export: bool,
    #[clap(long, help = "How many wallets to generate", default_value = "10")]
    wallets_quantity: usize,
    #[clap(
        help = "Files names will be automatically generated based on this prefix",
        default_value = "wallet"
    )]
    output_prefix: String,
}

#[derive(clap::Args)]
#[command(about = "Interactive mode. Will guide you asking questions")]
struct InteractiveArgs {
    #[clap(
        long,
        help = DIFFICULTY_HELP,
    )]
    difficulty: Option<KeyDerivationDifficulty>,
    #[clap(
        long,
        help = KEYFILE_HELP
    )]
    keyfile: Vec<String>,
    #[clap(
        long,
        action,
        help = ENABLE_DURESS_WALLET
    )]
    enable_duress_wallet: bool,

    #[clap(
        long,
        env = PASSWORD_ENV,
        help = PASSWORD_HELP
    )]
    password: Option<String>,
}

#[derive(clap::Args)]
#[command(about = "Run the key derivation for different difficulty levels and print the duration")]
struct BenchmarkArgs;

#[derive(clap::Args)]
#[command(about = "Shows the version")]
struct VersionArgs;

#[derive(Subcommand)]
enum Commands {
    Interactive(InteractiveArgs),
    SinglesigGenerate(SinglesigGenerateArgs),
    MultisigGenerate(MultisigGenerateArgs),
    SinglesigOpen(SinglesigOpenArgs),
    MultisigOpen(MultisigOpenArgs),
    SinglesigBatchGenerateExport(SinglesigBatchGenerateExportArgs),
    Benchmark(BenchmarkArgs),
    Version(VersionArgs),
}

const ABOUT: &str = "
frozenkrill: A minimalist Bitcoin wallet focused on cold storage

A cold storage wallet is used to receive and store bitcoins without a connection to internet.
This wallet is composed of the seeds (12 or 24 words) strongly encrypted with brute-force resistant algorithms and parameters.
If a keyfile and a strong password is used, it's possible to save the wallet file in relatively unsafe storage system (like cloud providers, email or with friends).

For maximum security, it's recommended to only generate and decrypt the wallet in a offline computer with a minimalist open-source Unix distribution (Linux/BSD).

Start with the 'interactive' command";

#[derive(Parser)]
#[command(about = ABOUT)]
struct Cli {
    #[clap(short, long, action, help = "Don't show 'info' messages")]
    quiet: bool,

    #[clap(
        long,
        action,
        help = "Will disable internet connectivity check (dangerous!)"
    )]
    disable_internet_check: bool,

    #[clap(long, help = "Use a less colorful theme for prompts")]
    use_simple_theme: bool,

    #[clap(subcommand)]
    command: Commands,
}

const ENGLISH: Language = Language::English;
const RUST_LOG: &str = "RUST_LOG";

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    if std::env::var(RUST_LOG).is_err() {
        if cli.quiet {
            std::env::set_var(RUST_LOG, "warn")
        } else {
            std::env::set_var(RUST_LOG, "info")
        }
    } else if cli.quiet {
        eprintln!("Warning: the {RUST_LOG} environment variable will override the --quiet flag");
    }
    let (term, theme) = get_term_theme(cli.use_simple_theme);
    custom_logger::init();
    #[cfg(windows)]
    {
        log::error!("You're using Windows");
        bail!("Don't be reckless, use a safer operating system")
    };
    #[cfg(not(unix))]
    bail!("This isn't a Unix-like operating system. As this is a untested setup, better contact the developers");
    match process(cli, theme, &term) {
        Ok(()) => Ok(()),
        Err(e) => {
            reset_terminal(&term);
            Err(e)
        }
    }
}

fn process(cli: Cli, theme: Box<dyn Theme>, term: &Term) -> Result<(), anyhow::Error> {
    let mut rng = rand::thread_rng();
    let mut secp = get_secp(&mut rng);
    let ic = InternetCheckerImpl::new(cli.disable_internet_check);
    match cli.command {
        Commands::SinglesigGenerate(args) => {
            commands::generate::singlesig_generate(
                theme.as_ref(),
                term,
                &mut secp,
                &mut rng,
                ic,
                args,
            )?;
        }
        Commands::MultisigGenerate(args) => {
            commands::generate::multisig_generate(
                theme.as_ref(),
                term,
                &mut secp,
                &mut rng,
                ic,
                args,
            )?;
        }
        Commands::SinglesigOpen(open_args) => match &open_args.command {
            SinglesigOpenCommands::ShowSecrets(args) => {
                commands::show_secrets::singlesig_show_secrets_parse_args(args)?;
                let (wallet, non_duress_password) = open_singlesig_wallet_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic,
                    &open_args,
                )?;
                commands::show_secrets::singlesig_show_secrets(
                    theme.as_ref(),
                    term,
                    &secp,
                    &wallet,
                    &non_duress_password,
                )?;
            }
            SinglesigOpenCommands::ExportPublicInfo(args) => {
                let (output_file_path, address_generation_params) =
                    commands::export_public_info::export_public_info_parse_args(
                        &open_args.common,
                        &args.common,
                    )?;
                let (wallet, non_duress_password) = open_singlesig_wallet_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic,
                    &open_args,
                )?;
                let non_duress_output_file_json = args
                    .non_duress_output_file_json
                    .as_ref()
                    .map(handle_output_path)
                    .transpose()?
                    .map(|p| p.to_path_buf());
                let duress_params = match non_duress_password {
                    Some(non_duress_password) => calculate_non_duress_output(
                        true,
                        &non_duress_output_file_json,
                        &Some(output_file_path.clone()),
                    )?
                    .map(
                        |non_duress_public_info_json_output| DuressPublicInfoParams {
                            non_duress_password: Arc::clone(&non_duress_password),
                            non_duress_public_info_json_output,
                        },
                    ),
                    None => None,
                };
                commands::export_public_info::export_singlesig(
                    theme.as_ref(),
                    term,
                    &secp,
                    &wallet,
                    &output_file_path,
                    &duress_params,
                    &address_generation_params,
                )?;
            }
            SinglesigOpenCommands::ShowReceivingQrCode(args) => {
                let (amount, address_index) =
                    commands::show_receiving_qr_code::show_receiving_qr_code_parse_args(args)?;
                let (wallet, non_duress_password) = open_singlesig_wallet_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic,
                    &open_args,
                )?;
                commands::show_receiving_qr_code::singlesig_show_receiving_qr_code(
                    theme.as_ref(),
                    term,
                    &secp,
                    &wallet,
                    amount,
                    address_index,
                    &non_duress_password,
                )?;
            }
            SinglesigOpenCommands::SignPsbt(args) => {
                commands::psbt::singlesig_sign_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic,
                    &open_args,
                    args,
                )?;
            }
            SinglesigOpenCommands::Reencode(args) => {
                let core_args =
                    commands::reencode::singlesig_reencode_parse_args(&open_args, args)?;
                // FIXME: should we ask/use non duress password here?
                let (wallet, _non_duress_password) = open_singlesig_wallet_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic.clone(),
                    &open_args,
                )?;

                commands::reencode::singlesig_core_reencode(
                    theme.as_ref(),
                    term,
                    &mut secp,
                    &mut rng,
                    ic,
                    &wallet,
                    core_args,
                )?;
            }
        },
        Commands::MultisigOpen(open_args) => match &open_args.command {
            MultisigOpenCommands::ShowSecrets(_) => {
                let wallet = open_multisig_wallet_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic,
                    &open_args,
                )?;
                commands::show_secrets::multisig_show_secrets(&secp, &wallet)?;
            }
            MultisigOpenCommands::ShowReceivingQrCode(args) => {
                let (amount, address_index) =
                    commands::show_receiving_qr_code::show_receiving_qr_code_parse_args(args)?;
                let wallet = open_multisig_wallet_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic,
                    &open_args,
                )?;
                commands::show_receiving_qr_code::multisig_show_receiving_qr_code(
                    &secp,
                    &wallet,
                    amount,
                    address_index,
                )?;
            }
            MultisigOpenCommands::ExportPublicInfo(args) => {
                let (output_file_path, address_generation_params) =
                    commands::export_public_info::export_public_info_parse_args(
                        &open_args.common,
                        &args.common,
                    )?;
                let wallet = open_multisig_wallet_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic,
                    &open_args,
                )?;
                commands::export_public_info::export_multisig(
                    &secp,
                    &wallet,
                    &output_file_path,
                    &address_generation_params,
                )?;
            }
            MultisigOpenCommands::SignPsbt(args) => {
                commands::psbt::multisig_sign_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic,
                    &open_args,
                    args,
                )?;
            }
            MultisigOpenCommands::Reencode(args) => {
                let core_args = commands::reencode::multisig_reencode_parse_args(&open_args, args)?;
                let wallet = open_multisig_wallet_non_interactive(
                    theme.as_ref(),
                    term,
                    &secp,
                    ic.clone(),
                    &open_args,
                )?;
                commands::reencode::multisig_core_reencode(
                    theme.as_ref(),
                    term,
                    &mut secp,
                    &mut rng,
                    ic,
                    wallet,
                    core_args,
                )?;
            }
        },
        Commands::SinglesigBatchGenerateExport(args) => {
            commands::batch_generate_export::batch_generate_export(
                theme.as_ref(),
                term,
                &mut secp,
                &mut rng,
                ic,
                &args,
            )?
        }
        Commands::Interactive(args) => commands::interactive::interactive(
            theme.as_ref(),
            term,
            &mut secp,
            &mut rng,
            ic,
            &args,
        )?,
        Commands::Benchmark(_) => commands::benchmark()?,
        Commands::Version(_) => eprintln!("frozenkrill {VERSION}"),
    };
    Ok(())
}

#[derive(Clone)]
pub(crate) struct InternetCheckerImpl {
    h: Arc<Mutex<Option<JoinHandle<bool>>>>,
    is_connected: Option<bool>,
}

pub(crate) trait InternetChecker: Clone {
    fn check(&mut self) -> anyhow::Result<()>;
}

mockall::mock! {
    InternetChecker {}     // Name of the mock struct, less the "Mock" prefix
    impl Clone for InternetChecker {   // specification of the trait to mock
        fn clone(&self) -> Self;
    }

    impl InternetChecker for InternetChecker {   // specification of the trait to mock
        fn check(&mut self) -> anyhow::Result<()>;
    }
}

impl InternetCheckerImpl {
    pub(crate) fn new(disable_check: bool) -> Self {
        if disable_check {
            log::warn!("Will proceed without checking if the device is connected to internet");
            log::warn!("Only do this for testing or on exceptional circumstances");
            Self {
                h: Arc::new(Mutex::new(None)),
                is_connected: None,
            }
        } else {
            Self {
                h: Arc::new(Mutex::new(Some(std::thread::spawn({
                    move || {
                        use std::net::ToSocketAddrs;
                        {
                            let i = "github.com";
                            match format!("{i}:443").to_socket_addrs() {
                                Ok(mut v) => {
                                    if v.next().is_some() {
                                        log::debug!("this is bad: {i} is reachable");
                                        return true;
                                    } else {
                                        log::debug!("this is good, {i} is unreachable because returned iterator is empty");
                                    }
                                }
                                Err(e) => log::debug!("this is good, {i} is unreachable: {e:?}"),
                            };
                        }
                        false
                    }
                })))),
                is_connected: None,
            }
        }
    }
}

impl InternetChecker for InternetCheckerImpl {
    fn check(&mut self) -> anyhow::Result<()> {
        if let Some(h) = self.h.lock().expect("to lock").take() {
            if !h.is_finished() {
                log::info!("Making sure internet is disconnected...")
            }
            let is_connected = h.join().expect("to join");
            self.is_connected = Some(is_connected);
            if is_connected {
                log::error!("You are connected to internet");
                eprintln!("This software should only be used in offline devices");
                eprintln!("Disconnect from internet and try again");
                eprintln!(
                    "Or use `frozenkrill --disable-internet-check` if you know what you're doing"
                );
                bail!("Internet is reachable")
            } else {
                Ok(())
            }
        } else if self.is_connected.unwrap_or_default() {
            bail!("Internet is reachable")
        } else {
            Ok(())
        }
    }
}

fn reset_terminal(term: &Term) {
    // TODO: fully restore terminal
    term.show_cursor().expect("to show cursor");
}

fn get_term_theme(use_simple_theme: bool) -> (Term, Box<dyn Theme>) {
    let theme: Box<dyn Theme> = if use_simple_theme {
        Box::new(SimpleTheme {})
    } else {
        Box::<ColorfulTheme>::default()
    };
    let term = Term::stderr(); // TODO: change to buffered_stderr when master get fixes
    (term, theme)
}

fn ask_password(theme: &dyn Theme, term: &Term) -> anyhow::Result<SecretString> {
    Ok(SecretString::new(
        dialoguer::Password::with_theme(theme)
            .with_prompt("Password")
            .with_confirmation("Confirm password", "Passwords don't match, try again")
            .allow_empty_password(false)
            .interact_on(term)
            .context("failure reading password")?,
    ))
}

fn ask_non_duress_password(theme: &dyn Theme, term: &Term) -> anyhow::Result<Arc<SecretString>> {
    Ok(Arc::new(SecretString::new(
        dialoguer::Password::with_theme(theme)
            .with_prompt("Enter a non duress seed password")
            .with_confirmation("Confirm password", "Passwords don't match, try again")
            .interact_on(term)
            .context("failure reading password")?,
    )))
}

pub(crate) fn get_derivation_key_spinner() -> ProgressBar {
    get_spinner("Deriving encryption keys from password and salt... please be patient")
}

fn warn_difficulty_level(difficulty: &KeyDerivationDifficulty) {
    if difficulty == &KeyDerivationDifficulty::Easy {
        log::warn!("The 'easy' difficulty level should only be used for testing");
        log::warn!("Or if you are very confident of your password and keyfiles strength");
    }
}

fn ui_derive_key(
    password: &SecretString,
    keyfiles: &[PathBuf],
    salt: &[u8; SALT_SIZE],
    difficulty: &KeyDerivationDifficulty,
) -> anyhow::Result<Secret<[u8; KEY_SIZE]>> {
    log::info!(
        "Using difficulty = {difficulty:?} ({}, {})",
        difficulty.estimate_time(),
        difficulty.estimate_memory()
    );
    log::info!("The above time is an estimate for modern cpus");
    log::info!("It may take much longer on some platforms");
    log::info!("This is our main protection against brute force attacks");
    let pb = get_derivation_key_spinner();
    let now = Instant::now();
    let key = default_derive_key(password, keyfiles, salt, difficulty).context("failure deriving key, check if you have enough memory, perhaps try with a easier --difficulty param")?;
    pb.finish_with_message(format!(
        "Key derivation finished in {:?}s",
        now.elapsed().as_secs()
    ));
    Ok(key)
}

fn handle_input_path(input_file: &str) -> anyhow::Result<Cow<Path>> {
    let input_file_path = Path::new(input_file);
    anyhow::ensure!(
        input_file_path.exists(),
        "The given file {input_file_path:?} doesn't exists"
    );
    Ok(input_file_path.absolutize()?)
}

fn handle_output_path<S: AsRef<std::ffi::OsStr> + ?Sized>(
    output_file: &S,
) -> anyhow::Result<Cow<Path>> {
    let output_file_path = Path::new(output_file);
    anyhow::ensure!(
        !output_file_path.exists(),
        "The output file {output_file_path:?} already exists, delete it or change the name"
    );
    Ok(output_file_path.absolutize()?)
}

fn ui_ask_manually_seed_input(
    rng: &mut impl CryptoRngCore,
    theme: &dyn Theme,
    term: &Term,
    word_count: &WordCount,
    always_hide_typed_seed: bool,
) -> anyhow::Result<Secret<Mnemonic>> {
    let total_words = word_count.to_integer();
    let will_fill_everything = dialoguer::Select::with_theme(theme)
        .with_prompt("Pick an option for the custom seed")
        .item(format!("I will manually input all {total_words} words"))
        .item(format!(
            "I will fill {} words and let the last word be automatically calculated (checksum)",
            total_words - 1
        ))
        .default(0)
        .interact_on(term)?
        == 0;
    let words_to_ask = if will_fill_everything {
        total_words
    } else {
        total_words - 1
    };
    let english = ENGLISH;
    let show_seeds_history = will_fill_everything && !always_hide_typed_seed;
    let word_list = english.word_list();
    let mut fuzzy_select = dialoguer::FuzzySelect::with_theme(theme);
    fuzzy_select
        .items(word_list)
        .default(0)
        .report(show_seeds_history)
        .max_length(10);
    loop {
        let mut words = Vec::with_capacity(total_words.into());
        for i in 1..=words_to_ask {
            let word_index = fuzzy_select
                .with_prompt(format!("Start typing... (word {i} of {words_to_ask})"))
                .interact_on(term)?;
            let word = word_list[word_index];
            words.push(word.to_owned());
        }
        if !will_fill_everything {
            words = mnemonic_utils::complete_words_with_checksum(rng, &words)?;
        }
        match Mnemonic::from_str(&words.join(" ")) {
            Ok(mnemonic) => return Ok(Secret::new(mnemonic)),
            Err(bip39::Error::InvalidChecksum) => {
                if !dialoguer::Confirm::with_theme(theme)
                    .with_prompt("The checksum is invalid. A word must be incorrect. Try again?")
                    .interact_on(term)?
                {
                    bail!("Aborting because of invalid seed");
                }
            }
            Err(e) => Err(e)?,
        }
    }
}

fn ui_get_singlesig_wallet_description(
    json_wallet_description: &Secret<SinglesigJsonWalletDescriptionV0>,
    seed_password: &Option<Arc<SecretString>>,
    secp: &Secp256k1<All>,
) -> anyhow::Result<SingleSigWalletDescriptionV0> {
    let w = json_wallet_description
        .expose_secret()
        .to(seed_password, secp)
        .context("failure parsing generated wallet")?;
    match SinglesigJsonWalletDescriptionV0::validate_same(json_wallet_description, &w, secp)? {
        Ok(()) => Ok(w),
        Err(e) => bail!("Validation error: {e:?}"),
    }
}
